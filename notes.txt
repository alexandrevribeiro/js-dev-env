# Development WebServers
    - http-server (Ultra-simple. Single command servers current directory)
    - live-server (Lightweight. Support live-reloading)
    - express (Comprehensive. Highly configurable. Can be used in Production. Can run it everywhere)
    - koa
    - hapi
    - budo (Integrates with Browserify. Hot reloading)
    - Webpack Dev Server (Built in to Webpack. Servers from memory. Hot reloading)
    - Browsersync (Dedicated IP for sharing work on LAN. All interactions remain in sync. Great for cross-device testing.)

# Sharing Work-in-progress
Packages used to share your local application across the internet without publishing it:
    - localtunnel (Easiest setup Ultra-versatile)
    - ngrok (Easy setup Secure)
    - Surge (No firewall hole, Hosting persists, Only static files)
    - Now (No firewall hole, Hosting persists, Only static files)

- localtunnel:
    * Using it to share your app:
        1) run you app (node myapp.js)
        2) Run the command: 'lt --port {port} [--subdomain {sub-domain}]'. Examples:
            - lt --port 3000
            - lt --port 3000 --subdomain alexandreribeiro
    * Combining it with 'Browsersync' would be a great idea to test your local app in muiltiple devices

# Automation
    - Grunt
        - The original one
        - It's configuration based. Configured through a json file
        - Writes intermediary files between steps
        - Large plugin ecosystem
    - Gulp
        - A more modern task runner
        - Focus in memory-streams (pipes)
        - Fast(er)
        - It's code based rather than configuration based.
        - Large plugin ecosystem
    - npm scripts
        - Declared in the "scripts" section in the package.json
        - Leverage your OS' command line
        - Directly use npm Packages
        - Call separate Node scripts
        - Convention-based pre/post hooks
        - Leverage world's largest package manager
        Why npm Scripts?
            - The simplicity of using npm packages directly
            - No need for separate plugins
            - Simpler debugging
            - Better docs
            - Easy to learn
            - Simple

# Transpiling
Transpilers:
    - Babel
        - Allows you to enjoy all the new features of JavaScript, even when they're still experimental.
        - Modern, standards-based JS
        - You write standardized JS
        - Leverage full JS Ecosystem
    - TypeScript
        - Superset of JavaScript
        - Adds additional functionalities to JavaScript
        - Enhanced autocompletion
        - Enhanced readability
        - Safer refactoring
        - Clearer intent

# 5 Modules Formats
    - Universal Module Definition (UMD)
        - Supports global variables
        - The past, so should be avoided
        - Syntax:
                myGlobal;

    - IIFE
        - The past, so should be avoided
        - Syntax:
            (function() { /* ... */ })();

    - Asynchronous Module Definition (ADM)
        - The past, so should be avoided
        - Syntax:
            define(['jq'], function(jq) {});

    - CommonJS (CJS)
        - Better, modern and more standardized approach
        - Used when working in node.js
        - Syntax:
            var jquery = require('jquery');
    
    - ES6 Modules
        - Better, modern and more standardized approach
        - Used when working in ES6
        - Syntax:
            import jQuery  from 'jquery';

# Why using ES6 Modules?
    - standardized
    - Statically analyzable, which means the code can be read and analyzed in a predictable way
        - Improved autocomplete
        - Intelligent refactoring
        - Code fails fast
        - Tree shaking
    - Easy to read
        - Named imports
        - Default exports

# Blundlers

    - Browserify (Simple)
        - The original. It helped popularize the idea of using npm packages on the Web
        - The first bundler to reach mass adoption
        - Bundle npm packages for the web.
        - Uses CommonJS pattern
        - Large plugin ecosystem

    - Webpack (Comprehensive)
        - Bundles much more than just JS
        - Offers a huge ecosystem of loaders, so you can easily teach Webpack to  intelligently handle your CSS, images, fonts and more 
        - You can import CSS, Images, etc. like JS
        - Built in hot-reloading web server
        - Servers files from memory, which speeds development, builds, and automatically updates client-side state to reflect code changes.

    - Rollup (Tree-shaking and performance, but new)
        - First tree shaking bundler, which means it eliminates code you're not using from the final bundle
        - It's faster loading production code (faster than Browserify and Webpack)
        - Quite new compared to established competitors like Browserify and Webpack
        - Great for library authors
        - Doesn't have hot reloading and code splitting yet

    - JSPM (Runtime loader, package manager)
        - Uses SystemJS, a universal module loader. Which means it can load a variety of JS module styles, including ADM, CommonJS and ES6 modules.
        - Can load modules at runtime
        - Has its own package manager
        - Can install from npm, git and more
        - Uses Rollup, so you get to enjoy Rollup's tree shaking

# Why using Webpack?
    - Much more than just JS: CSS, Images, Fonts and HTML.
    - Bundle splitting, which means you can generate separate bundles for different sections of your app, so they're download on demand
    - Includes built-in Web server that supports hot module reloading
    - Webpack 2 offers tree shaking
    - For now it's the most used bundler

# Sourcemaps
    - Maps the bundled, transpiled and minified code back to original source
    - They can be automatically generated as part of our builds
    - Sourcemaps are downloaded only when you open developer tools
    - It's defined by the 'devtool' option in the Webpack config file (https://webpack.js.org/configuration/devtool/)
    - To debug the code you should write a "debugger;" at the point you want to stop