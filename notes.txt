# Development WebServers
    - http-server (Ultra-simple. Single command servers current directory)
    - live-server (Lightweight. Support live-reloading)
    - express (Comprehensive. Highly configurable. Can be used in Production. Can run it everywhere)
    - koa
    - hapi
    - budo (Integrates with Browserify. Hot reloading)
    - Webpack Dev Server (Built in to Webpack. Servers from memory. Hot reloading)
    - Browsersync (Dedicated IP for sharing work on LAN. All interactions remain in sync. Great for cross-device testing.)

# Sharing Work-in-progress
Packages used to share your local application across the internet without publishing it:
    - localtunnel (Easiest setup Ultra-versatile)
    - ngrok (Easy setup Secure)
    - Surge (No firewall hole, Hosting persists, Only static files)
    - Now (No firewall hole, Hosting persists, Only static files)

- localtunnel:
    * Using it to share your app:
        1) run you app (node myapp.js)
        2) Run the command: 'lt --port {port} [--subdomain {sub-domain}]'. Examples:
            - lt --port 3000
            - lt --port 3000 --subdomain alexandreribeiro
    * Combining it with 'Browsersync' would be a great idea to test your local app in muiltiple devices

# Automation
    - Grunt
        - The original one
        - It's configuration based. Configured through a json file
        - Writes intermediary files between steps
        - Large plugin ecosystem
    - Gulp
        - A more modern task runner
        - Focus in memory-streams (pipes)
        - Fast(er)
        - It's code based rather than configuration based.
        - Large plugin ecosystem
    - npm scripts
        - Declared in the "scripts" section in the package.json
        - Leverage your OS' command line
        - Directly use npm Packages
        - Call separate Node scripts
        - Convention-based pre/post hooks
        - Leverage world's largest package manager
        Why npm Scripts?
            - The simplicity of using npm packages directly
            - No need for separate plugins
            - Simpler debugging
            - Better docs
            - Easy to learn
            - Simple

# Transpiling
Transpilers:
    - Babel
        - Allows you to enjoy all the new features of JavaScript, even when they're still experimental.
        - Modern, standards-based JS
        - You write standardized JS
        - Leverage full JS Ecosystem
    - TypeScript
        - Superset of JavaScript
        - Adds additional functionalities to JavaScript
        - Enhanced autocompletion
        - Enhanced readability
        - Safer refactoring
        - Clearer intent

# 5 Modules Formats
    - Universal Module Definition (UMD)
        - Supports global variables
        - The past, so should be avoided
        - Syntax:
                myGlobal;

    - IIFE
        - The past, so should be avoided
        - Syntax:
            (function() { /* ... */ })();

    - Asynchronous Module Definition (ADM)
        - The past, so should be avoided
        - Syntax:
            define(['jq'], function(jq) {});

    - CommonJS (CJS)
        - Better, modern and more standardized approach
        - Used when working in node.js
        - Syntax:
            var jquery = require('jquery');
    
    - ES6 Modules
        - Better, modern and more standardized approach
        - Used when working in ES6
        - Syntax:
            import jQuery  from 'jquery';

# Why use ES6 Modules?
    - standardized
    - Statically analyzable, which means the code can be read and analyzed in a predictable way
        - Improved autocomplete
        - Intelligent refactoring
        - Code fails fast
        - Tree shaking
    - Easy to read
        - Named imports
        - Default exports